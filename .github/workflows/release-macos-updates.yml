name: Release macOS updates

on:
  push:
    tags:
      - "v*"
  release:
    types:
      - published
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag to publish in alexllenaf/INTERLENA-updates (example: v1.1.9)"
        required: true
        type: string
      notes:
        description: "Release notes (optional)"
        required: false
        type: string

permissions:
  contents: read

concurrency:
  group: macos-release-${{ github.event.release.tag_name || inputs.tag || github.run_id }}
  cancel-in-progress: false

env:
  UPDATES_REPO: alexllenaf/INTERLENA-updates
  TAG_NAME: ${{ github.event.release.tag_name || inputs.tag || github.ref_name }}
  RELEASE_NOTES: ${{ github.event.release.body || inputs.notes || '' }}

jobs:
  build-macos:
    name: Build macOS (${{ matrix.arch_slug }})
    runs-on: ${{ matrix.runs_on }}
    timeout-minutes: 90
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch_slug: arm64
            runs_on: macos-14
            host_triple: aarch64-apple-darwin
            platform_key: darwin-aarch64
          - arch_slug: x64
            runs_on: macos-15-intel
            host_triple: x86_64-apple-darwin
            platform_key: darwin-x86_64

    steps:
      - name: Checkout private source repo
        uses: actions/checkout@v4

      - name: Validate required secrets
        env:
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
        run: |
          set -euo pipefail
          missing=()
          for secret_name in TAURI_PRIVATE_KEY TAURI_KEY_PASSWORD
          do
            if [ -z "${!secret_name:-}" ]; then
              missing+=("$secret_name")
            fi
          done

          if [ "${#missing[@]}" -gt 0 ]; then
            echo "::error::Missing required secrets: ${missing[*]}"
            exit 1
          fi

      - name: Resolve Apple signing mode
        id: signing_mode
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          set -euo pipefail
          has_apple_signing=true
          missing=()
          for secret_name in \
            APPLE_CERTIFICATE \
            APPLE_CERTIFICATE_PASSWORD \
            APPLE_SIGNING_IDENTITY \
            APPLE_ID \
            APPLE_PASSWORD \
            APPLE_TEAM_ID
          do
            if [ -z "${!secret_name:-}" ]; then
              has_apple_signing=false
              missing+=("$secret_name")
            fi
          done

          echo "has_apple_signing=$has_apple_signing" >> "$GITHUB_OUTPUT"
          if [ "$has_apple_signing" = "true" ]; then
            echo "Apple signing/notarization is enabled."
          else
            echo "::warning::Apple signing/notarization disabled. Missing secrets: ${missing[*]}"
            echo "::warning::Resulting app may show 'developer cannot be verified'."
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: frontend/package-lock.json

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install frontend dependencies
        run: npm ci --prefix frontend

      - name: Build backend sidecar binary
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          pip install -r backend/requirements.txt pyinstaller
          python backend/build_backend.py
          cp "backend/dist/interview-atlas-backend" "backend/dist/interview-atlas-backend-${{ matrix.host_triple }}"
          chmod +x "backend/dist/interview-atlas-backend-${{ matrix.host_triple }}"

      - name: Build macOS app bundle (signed)
        if: steps.signing_mode.outputs.has_apple_signing == 'true'
        working-directory: frontend
        env:
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: npm run tauri:build

      - name: Build macOS app bundle (unsigned)
        if: steps.signing_mode.outputs.has_apple_signing != 'true'
        working-directory: frontend
        env:
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
        run: npm run tauri:build

      - name: Collect architecture artifacts
        run: |
          set -euo pipefail
          APP_PATH="$(find frontend/src-tauri/target/release/bundle/macos -maxdepth 1 -name '*.app' -print -quit)"
          DMG_PATH="$(find frontend/src-tauri/target/release/bundle/dmg -maxdepth 1 -name '*.dmg' -print -quit)"
          TAR_PATH="$(find frontend/src-tauri/target/release/bundle/macos -maxdepth 1 -name '*.app.tar.gz' -print -quit)"
          SIG_PATH="${TAR_PATH}.sig"

          test -n "${APP_PATH:-}" && test -d "$APP_PATH"
          test -n "${DMG_PATH:-}" && test -f "$DMG_PATH"
          test -n "${TAR_PATH:-}" && test -f "$TAR_PATH"
          test -n "${SIG_PATH:-}" && test -f "$SIG_PATH"

          OUT_DIR="$RUNNER_TEMP/interview-atlas-${{ matrix.arch_slug }}"
          mkdir -p "$OUT_DIR"
          cp "$DMG_PATH" "$OUT_DIR/Interview.Atlas-${{ matrix.arch_slug }}.dmg"
          cp "$TAR_PATH" "$OUT_DIR/Interview.Atlas-${{ matrix.arch_slug }}.app.tar.gz"
          cp "$SIG_PATH" "$OUT_DIR/Interview.Atlas-${{ matrix.arch_slug }}.app.tar.gz.sig"

          cat > "$OUT_DIR/meta-${{ matrix.arch_slug }}.json" <<EOF
          {
            "arch_slug": "${{ matrix.arch_slug }}",
            "platform_key": "${{ matrix.platform_key }}",
            "dmg": "Interview.Atlas-${{ matrix.arch_slug }}.dmg",
            "tar": "Interview.Atlas-${{ matrix.arch_slug }}.app.tar.gz",
            "sig": "Interview.Atlas-${{ matrix.arch_slug }}.app.tar.gz.sig"
          }
          EOF

      - name: Verify codesign (only when Apple signing is enabled)
        if: steps.signing_mode.outputs.has_apple_signing == 'true'
        run: |
          set -euo pipefail
          APP_PATH="$(find frontend/src-tauri/target/release/bundle/macos -maxdepth 1 -name '*.app' -print -quit)"
          test -n "${APP_PATH:-}" && test -d "$APP_PATH"
          codesign --verify --deep --strict --verbose=2 "$APP_PATH"

      - name: Verify Gatekeeper + notarization (only when Apple signing is enabled)
        if: steps.signing_mode.outputs.has_apple_signing == 'true'
        run: |
          set -euo pipefail
          APP_PATH="$(find frontend/src-tauri/target/release/bundle/macos -maxdepth 1 -name '*.app' -print -quit)"
          DMG_PATH="$(find frontend/src-tauri/target/release/bundle/dmg -maxdepth 1 -name '*.dmg' -print -quit)"

          test -n "${APP_PATH:-}" && test -d "$APP_PATH"
          test -n "${DMG_PATH:-}" && test -f "$DMG_PATH"

          spctl --assess --type execute --verbose=4 "$APP_PATH"
          xcrun stapler validate "$APP_PATH"
          xcrun stapler validate "$DMG_PATH"

      - name: Upload build outputs
        uses: actions/upload-artifact@v4
        with:
          name: release-${{ matrix.platform_key }}
          path: ${{ runner.temp }}/interview-atlas-${{ matrix.arch_slug }}
          if-no-files-found: error

  publish-release-assets:
    name: Publish assets to updates repo
    needs: build-macos
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Checkout private source repo
        uses: actions/checkout@v4

      - name: Validate publish secret
        env:
          UPDATES_REPO_TOKEN: ${{ secrets.UPDATES_REPO_TOKEN }}
        run: |
          set -euo pipefail
          if [ -z "${UPDATES_REPO_TOKEN:-}" ]; then
            echo "::error::Missing required secret: UPDATES_REPO_TOKEN"
            exit 1
          fi

      - name: Download architecture artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: release-*
          merge-multiple: true
          path: ${{ runner.temp }}/release-bundle

      - name: Build latest.json
        run: |
          set -euo pipefail
          OUT_DIR="$RUNNER_TEMP/release-bundle"
          test -f "$OUT_DIR/Interview.Atlas-arm64.dmg"
          test -f "$OUT_DIR/Interview.Atlas-arm64.app.tar.gz"
          test -f "$OUT_DIR/Interview.Atlas-arm64.app.tar.gz.sig"
          test -f "$OUT_DIR/Interview.Atlas-x64.dmg"
          test -f "$OUT_DIR/Interview.Atlas-x64.app.tar.gz"
          test -f "$OUT_DIR/Interview.Atlas-x64.app.tar.gz.sig"

          cp "$OUT_DIR/Interview.Atlas-arm64.dmg" "$OUT_DIR/Interview.Atlas.dmg"
          cp "$OUT_DIR/Interview.Atlas-arm64.app.tar.gz" "$OUT_DIR/Interview.Atlas.app.tar.gz"
          cp "$OUT_DIR/Interview.Atlas-arm64.app.tar.gz.sig" "$OUT_DIR/Interview.Atlas.app.tar.gz.sig"

          VERSION="$(node -p "require('./frontend/src-tauri/tauri.conf.json').package.version")"
          PUBLISHED_AT="$(date -u '+%Y-%m-%dT%H:%M:%SZ')"
          export VERSION PUBLISHED_AT OUT_DIR
          export ASSET_BASE_URL="https://github.com/${UPDATES_REPO}/releases/latest/download"
          export ARM_SIG="$(tr -d '\r\n' < "$OUT_DIR/Interview.Atlas-arm64.app.tar.gz.sig")"
          export X64_SIG="$(tr -d '\r\n' < "$OUT_DIR/Interview.Atlas-x64.app.tar.gz.sig")"

          if [ -z "${RELEASE_NOTES// }" ]; then
            export RELEASE_NOTES="Interview Atlas ${TAG_NAME}."
          fi

          node <<'NODE'
          const fs = require("fs");
          const path = require("path");

          const outDir = process.env.OUT_DIR;
          const base = process.env.ASSET_BASE_URL;
          const payload = {
            version: process.env.VERSION,
            notes: process.env.RELEASE_NOTES,
            pub_date: process.env.PUBLISHED_AT,
            url: `${base}/Interview.Atlas-arm64.dmg`,
            download_url: `${base}/Interview.Atlas-arm64.dmg`,
            downloads: {
              "darwin-aarch64": { url: `${base}/Interview.Atlas-arm64.dmg` },
              "darwin-x86_64": { url: `${base}/Interview.Atlas-x64.dmg` },
              default: `${base}/Interview.Atlas-arm64.dmg`
            },
            platforms: {
              "darwin-aarch64": {
                signature: process.env.ARM_SIG,
                url: `${base}/Interview.Atlas-arm64.app.tar.gz`
              },
              "darwin-x86_64": {
                signature: process.env.X64_SIG,
                url: `${base}/Interview.Atlas-x64.app.tar.gz`
              }
            }
          };
          fs.writeFileSync(path.join(outDir, "latest.json"), `${JSON.stringify(payload, null, 2)}\n`);
          NODE

      - name: Publish assets to public updates repo
        env:
          GH_TOKEN: ${{ secrets.UPDATES_REPO_TOKEN }}
        run: |
          set -euo pipefail
          OUT_DIR="$RUNNER_TEMP/release-bundle"

          NOTES_FILE="$RUNNER_TEMP/release-notes.txt"
          printf '%s\n' "${RELEASE_NOTES:-Interview Atlas ${TAG_NAME}.}" > "$NOTES_FILE"
          TITLE="Interview Atlas ${TAG_NAME#v}"

          if gh release view "$TAG_NAME" --repo "$UPDATES_REPO" >/dev/null 2>&1; then
            gh release edit "$TAG_NAME" \
              --repo "$UPDATES_REPO" \
              --title "$TITLE" \
              --notes-file "$NOTES_FILE"
          else
            gh release create "$TAG_NAME" \
              --repo "$UPDATES_REPO" \
              --title "$TITLE" \
              --notes-file "$NOTES_FILE"
          fi

          gh release upload "$TAG_NAME" \
            --repo "$UPDATES_REPO" \
            --clobber \
            "$OUT_DIR/Interview.Atlas-arm64.dmg" \
            "$OUT_DIR/Interview.Atlas-arm64.app.tar.gz" \
            "$OUT_DIR/Interview.Atlas-arm64.app.tar.gz.sig" \
            "$OUT_DIR/Interview.Atlas-x64.dmg" \
            "$OUT_DIR/Interview.Atlas-x64.app.tar.gz" \
            "$OUT_DIR/Interview.Atlas-x64.app.tar.gz.sig" \
            "$OUT_DIR/Interview.Atlas.dmg" \
            "$OUT_DIR/Interview.Atlas.app.tar.gz" \
            "$OUT_DIR/Interview.Atlas.app.tar.gz.sig" \
            "$OUT_DIR/latest.json"
